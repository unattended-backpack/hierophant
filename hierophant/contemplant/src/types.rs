use alloy_primitives::B256;
use network_lib::ContemplantProofStatus;
use serde::{Deserialize, Serialize};
use sp1_sdk::{SP1Proof, SP1ProofWithPublicValues, SP1PublicValues};
use std::collections::HashMap;
use tokio::sync::RwLock;

pub type ProofStore = RwLock<HashMap<B256, ContemplantProofStatus>>;

/// A proof generated by the SP1 RISC-V zkVM bundled together with the public values and the
/// version.
/*
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SP1ProofWithPublicValues {
    /// The raw proof generated by the SP1 RISC-V zkVM.
    pub proof: SP1Proof,
    /// The public values generated by the SP1 RISC-V zkVM.
    pub public_values: SP1PublicValues,
    /// The version of the SP1 RISC-V zkVM (not necessary but useful for detecting version
    /// mismatches).
    pub sp1_version: String,
    /// The integrity proof generated by the TEE server.
    pub tee_proof: Option<Vec<u8>>,
}
*/
// The proof generated by the prover network.
//
// Since [`bincode`] is not self describing, it cannot handle "nullable" optional values.
//
// This is the same exact type as ProofFromNetwork in sp1_sdk but their's isn't public
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct ProofFromNetwork {
    proof: SP1Proof,
    public_values: SP1PublicValues,
    sp1_version: String,
}

impl From<SP1ProofWithPublicValues> for ProofFromNetwork {
    fn from(value: SP1ProofWithPublicValues) -> Self {
        Self {
            proof: value.proof,
            public_values: value.public_values,
            sp1_version: value.sp1_version,
        }
    }
}
